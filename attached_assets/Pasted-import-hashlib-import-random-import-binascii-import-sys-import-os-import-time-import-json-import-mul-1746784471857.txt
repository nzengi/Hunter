import hashlib
import random
import binascii
import sys
import os
import time
import json
import multiprocessing
from multiprocessing import Pool, cpu_count
import coincurve
import base58

def generate_random_private_key(start_range, end_range):
    """Generate a single random private key in the specified range"""
    # The range is too large for a simple randint, so we need to be a bit clever
    range_size = end_range - start_range
    
    # Generate a random value in the range by creating bytes directly
    random_bytes = bytearray(32)  # 32 bytes for a Bitcoin private key
    for i in range(32):
        random_bytes[i] = random.randint(0, 255)
        
    # Convert to an integer
    random_int = int.from_bytes(random_bytes, byteorder='big')
    
    # Scale to our range
    scaled_int = start_range + (random_int % range_size)
    
    # Convert back to bytes
    return scaled_int.to_bytes(32, byteorder='big')

def generate_random_private_keys(start_range, end_range, count=1000):
    """Generate batch of random private keys"""
    for _ in range(count):
        yield generate_random_private_key(start_range, end_range)

def get_public_key(private_key, compressed=True):
    """Get public key from private key using coincurve (fast)"""
    if isinstance(private_key, str):
        private_key = bytes.fromhex(private_key)
    
    # Use coincurve for much faster key derivation
    private_key_obj = coincurve.PrivateKey(private_key)
    return private_key_obj.public_key.format(compressed=compressed)

def hash160(data):
    """Perform SHA-256 and RIPEMD-160 hash functions"""
    # Use built-in function from coincurve if it's a public key
    if isinstance(data, coincurve.PublicKey):
        return data.hash
    
    # Otherwise do it manually
    sha256_hash = hashlib.sha256(data).digest()
    ripemd160_hash = hashlib.new('ripemd160')
    ripemd160_hash.update(sha256_hash)
    return ripemd160_hash.digest()

def double_sha256(data):
    """Perform double SHA-256 hash"""
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

def get_pubkey_hash(private_key, compressed=True):
    """Get the RIPEMD-160 hash of the public key (pubkey hash)"""
    if isinstance(private_key, str):
        private_key = bytes.fromhex(private_key)
    
    # Get the public key
    private_key_obj = coincurve.PrivateKey(private_key)
    pub_key = private_key_obj.public_key
    public_key_bytes = pub_key.format(compressed=compressed)
    
    # Get the pubkey hash (RIPEMD-160)
    pubkey_hash = hash160(public_key_bytes)
    return pubkey_hash.hex()

def private_key_to_address(private_key, compressed=True):
    """Generate a compressed Bitcoin address from a private key using coincurve"""
    try:
        # Get the public key using coincurve (faster)
        if isinstance(private_key, coincurve.PrivateKey):
            pub_key = private_key.public_key
            public_key_bytes = pub_key.format(compressed=compressed)
        else:
            if isinstance(private_key, str):
                private_key = bytes.fromhex(private_key)
            pub_key = coincurve.PublicKey.from_secret(private_key)
            public_key_bytes = pub_key.format(compressed=compressed)
        
        # Hash160 of the public key
        hash160_bytes = hash160(public_key_bytes)
        
        # Add version byte (0x00 for mainnet)
        versioned_hash = b'\x00' + hash160_bytes
        
        # Double SHA-256 checksum
        checksum = double_sha256(versioned_hash)[:4]
        
        # Base58Check encoding
        address = base58.b58encode(versioned_hash + checksum).decode('utf-8')
        return address
    except Exception as e:
        print(f"Error in key conversion: {str(e)}")
        raise

def check_address_match(address, prefix, suffix):
    """Check if address starts with prefix and ends with suffix"""
    if address.startswith(prefix) and address.endswith(suffix):
        return True
    return False

def save_match_to_file(match_data, filename="found_matches.json"):
    """Save match data to a JSON file"""
    try:
        # Use file locking for thread safety
        with multiprocessing.Lock():
            # Load existing data if file exists
            if os.path.exists(filename):
                with open(filename, 'r') as f:
                    try:
                        data = json.load(f)
                    except json.JSONDecodeError:
                        data = []
            else:
                data = []
            
            # Append new match
            data.append(match_data)
            
            # Write back to file
            with open(filename, 'w') as f:
                json.dump(data, f, indent=4)
                
            print(f"Match saved to {filename}")
    except Exception as e:
        print(f"Error saving match to file: {str(e)}")

def process_batch(args):
    """Process a batch of private keys"""
    prefix, suffix, target_address, target_pubkey_hash, batch_size, start_range, end_range = args
    exact_match = False
    matches = []
    
    # Generate private keys for this worker
    for private_key in generate_random_private_keys(start_range, end_range, batch_size):
        try:
            # Get the pubkey hash directly (skipping address encoding for speed)
            pubkey_hash = get_pubkey_hash(private_key)
            
            # Fast exact match check using pubkey hash (much faster than address comparison)
            if pubkey_hash == target_pubkey_hash:
                # Only generate the full address if we found a match
                address = private_key_to_address(private_key, compressed=True)
                match_data = {
                    "address": address,
                    "private_key_hex": private_key.hex(),
                    "pubkey_hash": pubkey_hash,
                    "match_type": "exact"
                }
                matches.append(match_data)
                exact_match = True
                
                # Print match info
                print(f"EXACT MATCH FOUND! Address: {address}")
                print(f"Private Key (hex): {private_key.hex()}")
                print(f"Public Key Hash (RIPEMD-160): {pubkey_hash}")
                
                # We found the exact match, no need to check more
                break
            
            # Only check prefix/suffix and generate address if we need to
            if prefix or suffix:
                # Generate full address for prefix/suffix check
                address = private_key_to_address(private_key, compressed=True)
                
                if check_address_match(address, prefix, suffix):
                    match_data = {
                        "address": address,
                        "private_key_hex": private_key.hex(),
                        "pubkey_hash": pubkey_hash,
                        "match_type": "prefix_suffix"
                    }
                    matches.append(match_data)
                    
                    # Print match info
                    print(f"Found matching address: {address}")
                    print(f"Target address: {target_address}")
                    print(f"Private Key (hex): {private_key.hex()}")
                    print(f"Public Key Hash (RIPEMD-160): {pubkey_hash}")
        except Exception as e:
            print(f"Error processing key: {str(e)}")
    
    # Return results
    return {
        "exact_match": exact_match,
        "matches": matches,
        "keys_checked": batch_size
    }

def format_int(n):
    """Format large integer with commas for readability"""
    return f"{n:,}"

def main(prefix, suffix, target_address, pub_key_hash, start_range, end_range):
    print("Starting advanced multi-core Bitcoin address search...")
    print(f"Looking for addresses with prefix: {prefix} and suffix: {suffix}")
    print(f"Target address: {target_address}")
    print(f"Target pubkey hash: {pub_key_hash}")
    print(f"Search range: 0x{start_range:x} - 0x{end_range:x}")
    print(f"Using {cpu_count()} CPU cores with advanced optimizations")
    print(f"Will continue until exact match is found, saving all prefix/suffix matches")
    
    # Determine optimal batch size based on CPU count
    workers = cpu_count()
    batch_size = max(1000, 10000 // workers)
    batch_size = min(batch_size, 5000)  # Limit batch size for better responsiveness
    
    keys_checked = 0
    start_time = time.time()
    iterations = 0
    max_iterations = 1000000000  # Increased for longer running
    matches_found = 0
    
    # Create multiprocessing pool
    pool = Pool(processes=workers)
    
    try:
        while iterations < max_iterations:
            # Create tasks for each worker
            batches = [(prefix, suffix, target_address, pub_key_hash, batch_size, start_range, end_range) for _ in range(workers)]
            
            # Process batches in parallel
            results = pool.map(process_batch, batches)
            
            # Process results
            iteration_matches = []
            for result in results:
                keys_checked += result["keys_checked"]
                if result["matches"]:
                    matches_found += len(result["matches"])
                    iteration_matches.extend(result["matches"])
                    
                    # Save matches to file
                    for match in result["matches"]:
                        save_match_to_file(match)
                        
                    # If we found an exact match, we're done
                    if result["exact_match"]:
                        exact_match = [m for m in result["matches"] if m["match_type"] == "exact"][0]
                        elapsed_time = time.time() - start_time
                        print(f"SUCCESS! Found EXACT match for target address: {target_address}")
                        print(f"Keys checked: {format_int(keys_checked)}")
                        print(f"Matches found: {matches_found}")
                        print(f"Time elapsed: {elapsed_time:.2f} seconds")
                        print(f"Speed: {keys_checked/elapsed_time:.2f} keys/second")
                        print(f"Private key: {exact_match['private_key_hex']}")
                        print(f"Public Key Hash: {exact_match['pubkey_hash']}")
                        
                        # Clean up and return
                        pool.close()
                        pool.join()
                        return exact_match['private_key_hex']
            
            # Update progress every iteration to reduce console output
            iterations += 1
            if iterations % 5 == 0 or iteration_matches:
                elapsed_time = time.time() - start_time
                keys_per_second = keys_checked / elapsed_time if elapsed_time > 0 else 0
                
                print(f"Iteration: {iterations}")
                print(f"Keys checked: {format_int(keys_checked)} @ {keys_per_second:.2f} keys/sec")
                print(f"Matches found: {matches_found}")
                print(f"Elapsed time: {elapsed_time:.2f} seconds")
                print(f"Probability space covered: ~{keys_checked * 100 / (end_range - start_range):.10f}%")
                print(f"Estimated time for 1% coverage: {(end_range - start_range) * 0.01 / keys_per_second / 3600:.2f} hours")
        
    except KeyboardInterrupt:
        elapsed_time = time.time() - start_time
        print("\nSearch interrupted by user.")
        print(f"Keys checked: {format_int(keys_checked)}")
        print(f"Matches found: {matches_found}")
        print(f"Time elapsed: {elapsed_time:.2f} seconds")
        
        # Clean up
        pool.close()
        pool.join()
        sys.exit(0)
    except Exception as e:
        print(f"Error in main loop: {str(e)}")
        import traceback
        traceback.print_exc()
    finally:
        # Make sure we always clean up the pool
        pool.close()
        pool.join()
    
    elapsed_time = time.time() - start_time
    print("Search completed. No exact match found.")
    print(f"Keys checked: {format_int(keys_checked)}")
    print(f"Matches found: {matches_found}")
    print(f"Time elapsed: {elapsed_time:.2f} seconds")
    return None

# Bitcoin Puzzle #69 için aralık
start_range = 0x100000000000000000
end_range = 0x200000000000000000

# Target Bitcoin Address
target_address = "19vkiEajfhuZ8bs8Zu2jgmC6oqZbWqhxhG"
pub_key_hash = "61eb8a50c86b0584bb727dd65bed8d2400d6d5aa"

# Prefix ve Suffix değerleri
prefix = "19vk"
suffix = "G"

# Run the program
if __name__ == "__main__":
    # Set the starting method for better multiprocessing
    multiprocessing.set_start_method('spawn', force=True)
    
    # Random seed
    random.seed()
    
    # Run the main function
    main(prefix, suffix, target_address, pub_key_hash, start_range, end_range) 